# 416. åˆ†å‰²ç­‰å’Œå­é›† - åŠ›æ‰£é¢˜è§£æœ€ä½³å®è·µ

è®¿é—®åŸæ–‡é“¾æ¥ï¼š[416. åˆ†å‰²ç­‰å’Œå­é›† - åŠ›æ‰£é¢˜è§£æœ€ä½³å®è·µ](https://leetcoder.net/zh/leetcode/416-partition-equal-subset-sum)ï¼Œä½“éªŒæ›´ä½³ï¼

åŠ›æ‰£é“¾æ¥ï¼š[416. åˆ†å‰²ç­‰å’Œå­é›†](https://leetcode.cn/problems/partition-equal-subset-sum), éš¾åº¦ï¼š**ä¸­ç­‰**ã€‚

## åŠ›æ‰£â€œ416. åˆ†å‰²ç­‰å’Œå­é›†â€é—®é¢˜æè¿°

ç»™ä½ ä¸€ä¸ª **åªåŒ…å«æ­£æ•´æ•°** çš„ **éç©º** æ•°ç»„ `nums` ã€‚è¯·ä½ åˆ¤æ–­æ˜¯å¦å¯ä»¥å°†è¿™ä¸ªæ•°ç»„åˆ†å‰²æˆä¸¤ä¸ªå­é›†ï¼Œä½¿å¾—ä¸¤ä¸ªå­é›†çš„å…ƒç´ å’Œç›¸ç­‰ã€‚

### [ç¤ºä¾‹ 1]

**è¾“å…¥**: `nums = [1,5,11,5]`

**è¾“å‡º**: `true`

**è§£é‡Š**: `æ•°ç»„å¯ä»¥åˆ†å‰²æˆ [1, 5, 5] å’Œ [11] ã€‚`

### [ç¤ºä¾‹ 2]

**è¾“å…¥**: `nums = [1,2,3,5]`

**è¾“å‡º**: `false`

**è§£é‡Š**: `æ•°ç»„ä¸èƒ½åˆ†å‰²æˆä¸¤ä¸ªå…ƒç´ å’Œç›¸ç­‰çš„å­é›†ã€‚`

### [çº¦æŸ]

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

## æ€è·¯ 1

- ç¬¬ä¸€æ¬¡çœ‹åˆ°è¿™é“é¢˜ï¼Œæˆ‘ä»¬å¯èƒ½æƒ³å¾ªç¯éå†æ•°ç»„çš„æ‰€æœ‰å­é›†ï¼Œå¦‚æœæœ‰ä¸€ä¸ªå­é›†çš„å’Œç­‰äº`å’Œçš„ä¸€åŠ`ï¼Œå°±è¿”å›`true`ã€‚è¿™å¯ä»¥ç”¨`å›æº¯ç®—æ³•`æ¥å®ç°ï¼Œä½†æ˜¯çœ‹åˆ°`nums.length <= 200`è¿™ä¸ªçº¦æŸï¼Œæˆ‘ä»¬ä¼°è®¡ç¨‹åºä¼šè¶…æ—¶ã€‚
- æœ¬é¢˜å¯ç”¨`0/1èƒŒåŒ…é—®é¢˜`ç®—æ³•æ¥è§£ã€‚

## â€œåŠ¨æ€è§„åˆ’â€çš„æ¨¡å¼

â€œåŠ¨æ€è§„åˆ’â€ï¼Œéœ€è¦ç”¨`dp`æ•°ç»„æ¥ä¿å­˜ç»“æœã€‚`dp[i][j]`çš„å€¼å¯ä»¥ç”±ä¸å®ƒç›¸å…³çš„ä¹‹å‰çš„`dp[x][y]`çš„å€¼æ¨å¯¼å‡ºæ¥ã€‚

#### â€œåŠ¨æ€è§„åˆ’â€åˆ†ä¸ºäº”æ­¥

1. ç¡®å®šæ•°ç»„`dp`çš„æ¯ä¸ªå€¼ä»£è¡¨çš„å«ä¹‰ã€‚
2. åˆå§‹åŒ–æ•°ç»„`dp`çš„å€¼ã€‚
3. æ ¹æ®ä¸€ä¸ªç¤ºä¾‹ï¼Œâ€œæŒ‰é¡ºåºâ€å¡«å…¥`dp`ç½‘æ ¼æ•°æ®ã€‚
4. æ ¹æ®`dp`ç½‘æ ¼æ•°æ®ï¼Œæ¨å¯¼å‡ºâ€œé€’æ¨å…¬å¼â€ã€‚
5. å†™å‡ºç¨‹åºï¼Œå¹¶æ‰“å°`dp`æ•°ç»„ï¼Œä¸åˆé¢„æœŸå°±è°ƒæ•´ã€‚

#### ç»†è¯´è¿™äº”æ­¥

1. ç¡®å®šæ•°ç»„`dp`çš„æ¯ä¸ªå€¼ä»£è¡¨çš„å«ä¹‰ã€‚
    - å…ˆç¡®å®š`dp`æ˜¯ä¸€ç»´æ•°ç»„è¿˜æ˜¯äºŒç»´æ•°ç»„ã€‚â€œä¸€ç»´æ»šåŠ¨æ•°ç»„â€æ„å‘³ç€æ¯æ¬¡è¿­ä»£æ—¶éƒ½ä¼šè¦†ç›–æ•°ç»„çš„å€¼ã€‚å¤§å¤šæ—¶å€™ï¼Œç”¨â€œä¸€ç»´æ»šåŠ¨æ•°ç»„â€ä»£æ›¿â€œäºŒç»´æ•°ç»„â€å¯ä»¥ç®€åŒ–ä»£ç ï¼›ä½†æœ‰äº›é¢˜ç›®ï¼Œæ¯”å¦‚è¦æ“ä½œâ€œä¸¤ä¸ªå¯¹ç­‰æ•°ç»„â€ï¼Œä¸ºäº†ç†è§£æ–¹ä¾¿ï¼Œè¿˜æ˜¯ä½¿ç”¨â€œäºŒç»´æ•°ç»„â€ã€‚
    - å°è¯•ä½¿ç”¨é—®é¢˜æ‰€æ±‚çš„`è¿”å›å€¼`çš„å«ä¹‰ä½œä¸º `dp[i]`ï¼ˆä¸€ç»´ï¼‰æˆ–`dp[i][j]`ï¼ˆäºŒç»´ï¼‰çš„å«ä¹‰ï¼Œçº¦60%çš„æ¦‚ç‡èƒ½è¡Œã€‚å¦‚æœä¸è¡Œï¼Œå†å°è¯•å…¶ä»–å«ä¹‰ã€‚
    - è®¾è®¡ä¸Šå°½é‡è€ƒè™‘ä¿å­˜æ›´ä¸°å¯Œçš„ä¿¡æ¯ï¼Œé‡å¤ä¿¡æ¯åªåœ¨æŸä¸ª`dp[i]`ä¸­ä¿å­˜ä¸€æ¬¡å°±å¤Ÿäº†ã€‚
    - ä½¿ç”¨ç®€åŒ–çš„å«ä¹‰ã€‚å¦‚æœç”¨`å¸ƒå°”å€¼`å¯ä»¥è§£å†³é—®é¢˜ï¼Œå°±ä¸è¦ç”¨`æ•°å€¼`ã€‚
2. åˆå§‹åŒ–æ•°ç»„`dp`çš„å€¼ã€‚`dp`çš„å€¼æ¶‰åŠä¸¤ä¸ªå±‚é¢ï¼š
    1. `dp`çš„é•¿åº¦ã€‚é€šå¸¸æ˜¯ï¼š`æ¡ä»¶æ•°ç»„é•¿åº¦åŠ 1`æˆ–`æ¡ä»¶æ•°ç»„é•¿åº¦`ã€‚
    2. `dp[i]`æˆ–`dp[i][j]`çš„å€¼ã€‚`dp[0]`æˆ–`dp[0][0]`æœ‰æ—¶éœ€è¦ç‰¹æ®Šå¤„ç†ã€‚
3. æ ¹æ®ä¸€ä¸ªç¤ºä¾‹ï¼Œâ€œæŒ‰é¡ºåºâ€å¡«å…¥`dp`ç½‘æ ¼æ•°æ®ã€‚
    - â€œé€’æ¨å…¬å¼â€æ˜¯â€œåŠ¨æ€è§„åˆ’â€ç®—æ³•çš„æ ¸å¿ƒã€‚ä½†â€œé€’æ¨å…¬å¼â€æ˜¯éšæ™¦çš„ï¼Œæƒ³å¾—åˆ°å®ƒï¼Œå°±éœ€è¦åˆ¶è¡¨ï¼Œç”¨æ•°æ®å¯å‘è‡ªå·±ã€‚
    - å¦‚æœåŸç¤ºä¾‹ä¸å¤Ÿå¥½ï¼Œéœ€è¦è‡ªå·±é‡æ–°è®¾è®¡ä¸€ä¸ªã€‚
    - æ ¹æ®ç¤ºä¾‹ï¼Œå¡«å…¥`dp`ç½‘æ ¼æ•°æ®ï¼Œéœ€è¦â€œæŒ‰é¡ºåºâ€å¡«ï¼Œè¿™æ˜¯å¾ˆé‡è¦çš„ï¼Œå› ä¸ºå®ƒå†³å®šäº†ä»£ç çš„éå†é¡ºåºã€‚
    - å¤§å¤šæ—¶å€™ï¼Œä»å·¦åˆ°å³ï¼Œä»ä¸Šåˆ°ä¸‹ã€‚ä½†æœ‰æ—¶éœ€è¦ä»å³å‘å·¦ã€ç”±ä¸‹è€Œä¸Šã€ä»ä¸­é—´å‘å³ï¼ˆæˆ–å·¦ï¼‰ï¼Œå¦‚â€œå›æ–‡ä¸²â€é—®é¢˜ã€‚æœ‰æ—¶ï¼Œè¿˜éœ€è¦ä¸€è¡Œéå†ä¸¤æ¬¡ï¼Œå…ˆæ­£å‘ï¼Œå†åå‘ã€‚
    - å½“é¡ºåºå†³å®šå¯¹äº†ï¼Œèµ·ç‚¹å°±å†³å®šå¥½äº†ï¼Œä»èµ·ç‚¹å‡ºå‘ï¼Œâ€œæŒ‰é¡ºåºâ€å¡«å†™`dp`ç½‘æ ¼æ•°æ®ï¼Œè¿™ä¹Ÿæ˜¯åœ¨æ¨¡æ‹Ÿç¨‹åºå¤„ç†çš„è¿‡ç¨‹ã€‚
    - åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œæ‚¨å°†è·å¾—å†™å‡ºâ€œé€’æ¨å…¬å¼â€çš„çµæ„Ÿã€‚å¦‚æœæ‚¨å·²ç»èƒ½æ¨å¯¼å‡ºå…¬å¼ï¼Œä¸éœ€è¦å¡«å®Œç½‘æ ¼ã€‚
4. æ ¹æ®`dp`ç½‘æ ¼æ•°æ®ï¼Œæ¨å¯¼å‡ºâ€œé€’æ¨å…¬å¼â€ã€‚
    - æœ‰ä¸‰ä¸ªç‰¹åˆ«çš„ä½ç½®éœ€è¦æ³¨æ„ï¼š `dp[i - 1][j - 1]`ã€`dp[i - 1][j]`å’Œ`dp[i][j - 1]`ï¼Œå½“å‰çš„ `dp[i][j]`å¾€å¾€å–å†³äºå®ƒä»¬ã€‚
    - æ“ä½œâ€œä¸¤ä¸ªå¯¹ç­‰æ•°ç»„â€æ—¶ï¼Œå› ä¸ºå¯¹ç§°æ€§ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦åŒæ—¶ä½¿ç”¨`dp[i - 1][j]`å’Œ`dp[i][j - 1]`ã€‚
5. å†™å‡ºç¨‹åºï¼Œå¹¶æ‰“å°`dp`æ•°ç»„ï¼Œä¸åˆé¢„æœŸå°±è°ƒæ•´ã€‚
    - é‡ç‚¹åˆ†æé‚£äº›ä¸åˆé¢„æœŸçš„æ•°å€¼ã€‚

è¯»å®Œäº†ä¸Šé¢çš„å†…å®¹ï¼Œæ˜¯ä¸æ˜¯æ„Ÿè§‰â€œåŠ¨æ€è§„åˆ’â€ä¹Ÿæ²¡æœ‰é‚£ä¹ˆéš¾äº†ï¼Ÿè¯•ç€è§£å‡ºè¿™é“é¢˜å§ã€‚ğŸ¤—

## â€œ0/1èƒŒåŒ…é—®é¢˜â€çš„æ¨¡å¼

å…¸å‹çš„â€œ0/1èƒŒåŒ…é—®é¢˜â€ï¼ŒæŒ‡æ¯ä¸ªâ€œç‰©å“â€åªèƒ½ä½¿ç”¨ä¸€æ¬¡ï¼Œæ¥å¡«å……â€œèƒŒåŒ…â€ã€‚â€œç‰©å“â€æœ‰â€œé‡é‡â€å’Œâ€œä»·å€¼â€å±æ€§ï¼Œæ±‚â€œèƒŒåŒ…â€èƒ½å­˜æ”¾çš„â€œç‰©å“â€çš„æœ€å¤§ä»·å€¼ã€‚

å…¶ç‰¹ç‚¹æ˜¯ï¼šæœ‰**ä¸€ç»„æ•°å­—**ï¼Œæ¯ä¸ªæ•°å­—åªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ï¼Œé€šè¿‡æŸç§è®¡ç®—å¾—åˆ°**å¦ä¸€ä¸ªæ•°å­—**ã€‚é—®é¢˜ä¹Ÿå¯ä»¥å˜æˆèƒ½å¦å¾—åˆ°ï¼Ÿæœ‰å¤šå°‘ç§å˜åŒ–ï¼Ÿç­‰ã€‚

å› ä¸ºâ€œ0/1èƒŒåŒ…é—®é¢˜â€å±äºâ€œåŠ¨æ€è§„åˆ’â€ï¼Œæ‰€ä»¥æˆ‘ä¼šç”¨â€œåŠ¨æ€è§„åˆ’â€çš„æ¨¡å¼è®²è§£ã€‚

1. ç¡®å®šæ•°ç»„`dp`çš„æ¯ä¸ªå€¼ä»£è¡¨çš„å«ä¹‰ã€‚
    - é¦–é€‰**ä¸€ç»´æ»šåŠ¨æ•°ç»„**ï¼Œä»£ç ç®€æ´ã€‚
    - ç¡®å®šä»€ä¹ˆæ˜¯â€œç‰©å“â€ï¼Œä»€ä¹ˆæ˜¯â€œèƒŒåŒ…â€ã€‚
    - å¦‚æœ`dp[j]`æ˜¯ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œåˆ™`dp[j]`è¡¨ç¤ºæ˜¯å¦å¯ä»¥å‰`i`ä¸ª`ç‰©å“`çš„`å’Œ`å¾—åˆ°`j`ã€‚
    - å¦‚æœ`dp[j]`æ˜¯ä¸€ä¸ªæ•°å€¼ï¼Œåˆ™`dp[j]`è¡¨ç¤ºæ˜¯åˆ©ç”¨å‰`i`ä¸ª`ç‰©å“`ï¼Œ`dp[j]`èƒ½è¾¾åˆ°çš„æ‰€æ±‚é—®é¢˜çš„æé™å€¼ã€‚
2. åˆå§‹åŒ–æ•°ç»„`dp`çš„å€¼ã€‚
    - ç¡®å®šâ€œèƒŒåŒ…â€çš„å¤§å°ã€‚éœ€è¦è®©èƒŒåŒ…å¤§å°å†åŠ 1ï¼Œå³æ’å…¥`dp[0]`åšä¸ºèµ·å§‹ç‚¹ï¼Œæ–¹ä¾¿ç†è§£å’Œå¼•ç”¨ã€‚
    - `dp[0]`æœ‰æ—¶éœ€è¦ç‰¹æ®Šå¤„ç†ã€‚
3. æ ¹æ®ä¸€ä¸ªç¤ºä¾‹ï¼Œâ€œæŒ‰é¡ºåºâ€å¡«å…¥`dp`ç½‘æ ¼æ•°æ®ã€‚
    - å…ˆåœ¨å¤–å±‚å¾ªç¯ä¸­ï¼Œ**éå†ç‰©å“**ã€‚
    - ååœ¨å†…å±‚å¾ªç¯ä¸­ï¼Œ**éå†èƒŒåŒ…å¤§å°**ã€‚
       - åœ¨éå†èƒŒåŒ…å¤§å°æ—¶ï¼Œç”±äº`dp[j]`å–å†³äº`dp[j]`å’Œ`dp[j - weights[i]]`ï¼Œå› æ­¤æˆ‘ä»¬åº”è¯¥**ä»å³åˆ°å·¦**éå†`dp`æ•°ç»„ã€‚
       - è¯·æ€è€ƒæ˜¯å¦å¯ä»¥ä»`ä»å·¦åˆ°å³`éå†`dp`æ•°ç»„ï¼Ÿ
4. æ ¹æ®`dp`ç½‘æ ¼æ•°æ®ï¼Œæ¨å¯¼å‡ºâ€œé€’æ¨å…¬å¼â€ã€‚
    - å¦‚æœ`dp[j]`æ˜¯ä¸€ä¸ªå¸ƒå°”å€¼ï¼š

    ```cpp
    dp[j] = dp[j] || dp[j - weights[i]]
    ```
    - å¦‚æœ`dp[j]`æ˜¯ä¸€ä¸ªæ•°å€¼ï¼š

    ```cpp
    dp[j] = min_or_max(dp[j], dp[j - weights[i]] + values[i])
    ```
5. å†™å‡ºç¨‹åºï¼Œå¹¶æ‰“å°`dp`æ•°ç»„ï¼Œä¸åˆé¢„æœŸå°±è°ƒæ•´ã€‚

## æ­¥éª¤

1. ç¡®å®š`dp[j]`çš„**å«ä¹‰**
    - `dp[j]`è¡¨ç¤ºæ˜¯å¦å‰`i`ä¸ª`nums`çš„`å’Œ`æ˜¯å¦ç­‰äº`j`ã€‚
    - `dp[j]`æ˜¯ä¸€ä¸ªå¸ƒå°”å€¼ã€‚
2. ç¡®å®š `dp` æ•°ç»„çš„åˆå§‹å€¼
    - ä¸¾ä¸ªä¾‹å­ï¼š

        ```
        nums = [1,5,11,5]ï¼Œæ‰€ä»¥ 'å’Œçš„ä¸€åŠ' æ˜¯ 11ã€‚
        èƒŒåŒ…çš„ `size` æ˜¯ '11 + 1'ï¼Œ`ç‰©å“` æ˜¯ `nums`ã€‚
        æ‰€ä»¥åˆå§‹åŒ–åï¼Œ'dp' æ•°ç»„å°†æ˜¯ï¼š
        #    0 1 2 3 4 5 6 7 8 9 10 11
        #    T F F F F F F F F F F  F # dp
        # 1
        # 5
        # 11
        # 5
        ```
    - `dp[0]` è®¾ç½®ä¸º `true`ï¼Œè¡¨ç¤ºä¸æ”¾ä»»ä½•ç‰©å“å³å¯å¾—åˆ°ç©ºèƒŒåŒ…ï¼Œå¦å¤–ï¼Œå®ƒä½œä¸ºèµ·å§‹å€¼ï¼Œåé¢çš„ `dp[j]` å°†ä¾èµ–å®ƒã€‚å¦‚æœä¸º `false`ï¼Œåˆ™ `dp[j]` çš„æ‰€æœ‰å€¼éƒ½å°†ä¸º `false`ã€‚
    - `dp[j] = false (j != 0)`ï¼Œè¡¨ç¤º0ä¸ª `nums`çš„å’Œä¸å¯èƒ½ç­‰äº `j`ã€‚

3. æ ¹æ®ä¸€ä¸ªç¤ºä¾‹ï¼Œâ€œæŒ‰é¡ºåºâ€å¡«å…¥`dp`ç½‘æ ¼æ•°æ®ã€‚

    ```
    1. ä½¿ç”¨ç¬¬ä¸€ä¸ªæ•°å­— '1'ã€‚
    #    0 1 2 3 4 5 6 7 8 9 10 11
    #    T F F F F F F F F F F  F
    # 1  T T F F F F F F F F F  F # dp
    ```

    ```
    2. ä½¿ç”¨ç¬¬äºŒä¸ªæ•°å­— '5'ã€‚
    #    0 1 2 3 4 5 6 7 8 9 10 11
    #    T F F F F F F F F F F  F
    # 1  T T F F F F F F F F F  F
    # 5  T T F F F T T F F F F  F
    ```

    ```
    3. ä½¿ç”¨ç¬¬ä¸‰ä¸ªæ•°å­— '11'ã€‚
    #    0 1 2 3 4 5 6 7 8 9 10 11
    #    T F F F F F F F F F F  F
    # 1  T T F F F F F F F F F  F
    # 5  T T F F F T T F F F F  F
    # 11 T T F F F T T F F F F  T
    ```

    ```
    3. ä½¿ç”¨æœ€åä¸€ä¸ªæ•°å­—â€œ5â€ã€‚
    #    0 1 2 3 4 5 6 7 8 9 10 11
    #    T F F F F F F F F F F  F
    # 1  T T F F F F F F F F F  F
    # 5  T T F F F T T F F F F  F
    # 11 T T F F F T T F F F F  T
    # 5  T T F F F T T F F F T  T # dp
    ```
4. æ ¹æ®`dp`ç½‘æ ¼æ•°æ®ï¼Œæ¨å¯¼å‡ºâ€œé€’æ¨å…¬å¼â€ã€‚

    ```cpp
    dp[j] = dp[j] || dp[j - nums[i]]
    ```
5. å†™å‡ºç¨‹åºï¼Œå¹¶æ‰“å°`dp`æ•°ç»„ï¼Œä¸åˆé¢„æœŸå°±è°ƒæ•´ã€‚

## å¤æ‚åº¦

- æ—¶é—´å¤æ‚åº¦: `O(n * sum/2)`.
- ç©ºé—´å¤æ‚åº¦: `O(sum/2)`.

## Python

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sum_ = sum(nums)

        if sum_ % 2 == 1:
            return False

        dp = [False] * ((sum_ // 2) + 1)
        dp[0] = True

        for num in nums:
            # If not traversing in reverse order, the newly assigned value `dp[j]` will act as `dp[j - num]` later,
            # then the subsequent `dp[j]` will be affected. But each `num` can only be used once!
            j = len(dp) - 1
            while j >= num:
                dp[j] = dp[j] or dp[j - num]
                j -= 1

        return dp[-1]
```

## C#

```csharp
public class Solution
{
    public bool CanPartition(int[] nums)
    {
        int sum = nums.Sum();

        if (sum % 2 == 1)
            return false;

        var dp = new bool[sum / 2 + 1];
        dp[0] = true;

        foreach (var num in nums)
        {
            for (var j = dp.GetUpperBound(0); j >= num; j--)
            {
                dp[j] = dp[j] || dp[j - num];
            }
        }

        return dp.Last();
    }
}
```

## C++

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        auto sum = reduce(nums.begin(), nums.end());

        if (sum % 2 == 1) {
            return false;
        }

        auto dp = vector<bool>(sum / 2 + 1);
        dp[0] = true;

        for (auto num : nums) {
            for (auto j = dp.size() - 1; j >= num; j--) {
                dp[j] = dp[j] || dp[j - num];
            }
        }

        return dp.back();
    }
};
```

## Java

```java
class Solution {
    public boolean canPartition(int[] nums) {
        var sum = IntStream.of(nums).sum();
        
        if (sum % 2 == 1) {
            return false;
        }

        var dp = new boolean[sum / 2 + 1];
        dp[0] = true;

        for (var num : nums) {
            for (var j = dp.length - 1; j >= num; j--) {
                dp[j] = dp[j] || dp[j - num];
            }
        }

        return dp[dp.length - 1];
    }
}
```

## JavaScript

```javascript
var canPartition = function (nums) {
  const sum = _.sum(nums)

  if (sum % 2 == 1) {
    return false
  }

  const dp = Array(sum / 2 + 1).fill(false)
  dp[0] = true

  for (const num of nums) {
    for (let j = dp.length - 1; j >= num; j--) {
      dp[j] = dp[j] || dp[j - num]
    }
  }

  return dp.at(-1)
};
```

## Go

```go
func canPartition(nums []int) bool {
    sum := 0
    for _, num := range nums {
        sum += num
    }

    if sum % 2 == 1 {
        return false
    }

    dp := make([]bool, sum / 2 + 1)
    dp[0] = true

    for _, num := range nums {
        for j := len(dp) - 1; j >= num; j-- {
            dp[j] = dp[j] || dp[j - num]
        }
    }

    return dp[len(dp) - 1]
}
```

## Ruby

```ruby
def can_partition(nums)
  sum = nums.sum

  return false if sum % 2 == 1

  dp = Array.new(sum / 2 + 1, false)
  dp[0] = true

  nums.each do |num|
    (num...dp.size).reverse_each do |j|
      dp[j] = dp[j] || dp[j - num]
    end
  end

  dp[-1]
end
```

## Other languages

```java
// Welcome to create a PR to complete the code of this language, thanks!
```

## æ€è·¯ 2

åœ¨*æ–¹æ¡ˆ 1*ä¸­ï¼Œéå†é¡ºåºæ˜¯ **ä»å³åˆ°å·¦**ï¼Œè¿™çœŸçš„å¾ˆé‡è¦ã€‚

é¢è¯•çš„æ—¶å€™ï¼Œä½ éœ€è¦è®°ä½å®ƒã€‚æœ‰ä»€ä¹ˆåŠæ³•å¯ä»¥ä¸ç”¨æ‹…å¿ƒéå†é¡ºåºï¼Ÿ

<details><summary>ç‚¹å‡»æŸ¥çœ‹ç­”æ¡ˆ</summary><p> åªè¦æŠŠåŸ`dp`å¤åˆ¶ä¸€ä»½ï¼Œå¹¶å¼•ç”¨å¤åˆ¶å“çš„å€¼ï¼Œå°±ä¸ç”¨æ‹…å¿ƒåŸ`dp`å€¼è¢«ä¿®æ”¹äº†ã€‚</p></details>

## â€œåŠ¨æ€è§„åˆ’â€çš„æ¨¡å¼

â€œåŠ¨æ€è§„åˆ’â€ï¼Œéœ€è¦ç”¨`dp`æ•°ç»„æ¥ä¿å­˜ç»“æœã€‚`dp[i][j]`çš„å€¼å¯ä»¥ç”±ä¸å®ƒç›¸å…³çš„ä¹‹å‰çš„`dp[x][y]`çš„å€¼æ¨å¯¼å‡ºæ¥ã€‚

#### â€œåŠ¨æ€è§„åˆ’â€åˆ†ä¸ºäº”æ­¥

1. ç¡®å®šæ•°ç»„`dp`çš„æ¯ä¸ªå€¼ä»£è¡¨çš„å«ä¹‰ã€‚
2. åˆå§‹åŒ–æ•°ç»„`dp`çš„å€¼ã€‚
3. æ ¹æ®ä¸€ä¸ªç¤ºä¾‹ï¼Œâ€œæŒ‰é¡ºåºâ€å¡«å…¥`dp`ç½‘æ ¼æ•°æ®ã€‚
4. æ ¹æ®`dp`ç½‘æ ¼æ•°æ®ï¼Œæ¨å¯¼å‡ºâ€œé€’æ¨å…¬å¼â€ã€‚
5. å†™å‡ºç¨‹åºï¼Œå¹¶æ‰“å°`dp`æ•°ç»„ï¼Œä¸åˆé¢„æœŸå°±è°ƒæ•´ã€‚

#### ç»†è¯´è¿™äº”æ­¥

1. ç¡®å®šæ•°ç»„`dp`çš„æ¯ä¸ªå€¼ä»£è¡¨çš„å«ä¹‰ã€‚
    - å…ˆç¡®å®š`dp`æ˜¯ä¸€ç»´æ•°ç»„è¿˜æ˜¯äºŒç»´æ•°ç»„ã€‚â€œä¸€ç»´æ»šåŠ¨æ•°ç»„â€æ„å‘³ç€æ¯æ¬¡è¿­ä»£æ—¶éƒ½ä¼šè¦†ç›–æ•°ç»„çš„å€¼ã€‚å¤§å¤šæ—¶å€™ï¼Œç”¨â€œä¸€ç»´æ»šåŠ¨æ•°ç»„â€ä»£æ›¿â€œäºŒç»´æ•°ç»„â€å¯ä»¥ç®€åŒ–ä»£ç ï¼›ä½†æœ‰äº›é¢˜ç›®ï¼Œæ¯”å¦‚è¦æ“ä½œâ€œä¸¤ä¸ªå¯¹ç­‰æ•°ç»„â€ï¼Œä¸ºäº†ç†è§£æ–¹ä¾¿ï¼Œè¿˜æ˜¯ä½¿ç”¨â€œäºŒç»´æ•°ç»„â€ã€‚
    - å°è¯•ä½¿ç”¨é—®é¢˜æ‰€æ±‚çš„`è¿”å›å€¼`çš„å«ä¹‰ä½œä¸º `dp[i]`ï¼ˆä¸€ç»´ï¼‰æˆ–`dp[i][j]`ï¼ˆäºŒç»´ï¼‰çš„å«ä¹‰ï¼Œçº¦60%çš„æ¦‚ç‡èƒ½è¡Œã€‚å¦‚æœä¸è¡Œï¼Œå†å°è¯•å…¶ä»–å«ä¹‰ã€‚
    - è®¾è®¡ä¸Šå°½é‡è€ƒè™‘ä¿å­˜æ›´ä¸°å¯Œçš„ä¿¡æ¯ï¼Œé‡å¤ä¿¡æ¯åªåœ¨æŸä¸ª`dp[i]`ä¸­ä¿å­˜ä¸€æ¬¡å°±å¤Ÿäº†ã€‚
    - ä½¿ç”¨ç®€åŒ–çš„å«ä¹‰ã€‚å¦‚æœç”¨`å¸ƒå°”å€¼`å¯ä»¥è§£å†³é—®é¢˜ï¼Œå°±ä¸è¦ç”¨`æ•°å€¼`ã€‚
2. åˆå§‹åŒ–æ•°ç»„`dp`çš„å€¼ã€‚`dp`çš„å€¼æ¶‰åŠä¸¤ä¸ªå±‚é¢ï¼š
    1. `dp`çš„é•¿åº¦ã€‚é€šå¸¸æ˜¯ï¼š`æ¡ä»¶æ•°ç»„é•¿åº¦åŠ 1`æˆ–`æ¡ä»¶æ•°ç»„é•¿åº¦`ã€‚
    2. `dp[i]`æˆ–`dp[i][j]`çš„å€¼ã€‚`dp[0]`æˆ–`dp[0][0]`æœ‰æ—¶éœ€è¦ç‰¹æ®Šå¤„ç†ã€‚
3. æ ¹æ®ä¸€ä¸ªç¤ºä¾‹ï¼Œâ€œæŒ‰é¡ºåºâ€å¡«å…¥`dp`ç½‘æ ¼æ•°æ®ã€‚
    - â€œé€’æ¨å…¬å¼â€æ˜¯â€œåŠ¨æ€è§„åˆ’â€ç®—æ³•çš„æ ¸å¿ƒã€‚ä½†â€œé€’æ¨å…¬å¼â€æ˜¯éšæ™¦çš„ï¼Œæƒ³å¾—åˆ°å®ƒï¼Œå°±éœ€è¦åˆ¶è¡¨ï¼Œç”¨æ•°æ®å¯å‘è‡ªå·±ã€‚
    - å¦‚æœåŸç¤ºä¾‹ä¸å¤Ÿå¥½ï¼Œéœ€è¦è‡ªå·±é‡æ–°è®¾è®¡ä¸€ä¸ªã€‚
    - æ ¹æ®ç¤ºä¾‹ï¼Œå¡«å…¥`dp`ç½‘æ ¼æ•°æ®ï¼Œéœ€è¦â€œæŒ‰é¡ºåºâ€å¡«ï¼Œè¿™æ˜¯å¾ˆé‡è¦çš„ï¼Œå› ä¸ºå®ƒå†³å®šäº†ä»£ç çš„éå†é¡ºåºã€‚
    - å¤§å¤šæ—¶å€™ï¼Œä»å·¦åˆ°å³ï¼Œä»ä¸Šåˆ°ä¸‹ã€‚ä½†æœ‰æ—¶éœ€è¦ä»å³å‘å·¦ã€ç”±ä¸‹è€Œä¸Šã€ä»ä¸­é—´å‘å³ï¼ˆæˆ–å·¦ï¼‰ï¼Œå¦‚â€œå›æ–‡ä¸²â€é—®é¢˜ã€‚æœ‰æ—¶ï¼Œè¿˜éœ€è¦ä¸€è¡Œéå†ä¸¤æ¬¡ï¼Œå…ˆæ­£å‘ï¼Œå†åå‘ã€‚
    - å½“é¡ºåºå†³å®šå¯¹äº†ï¼Œèµ·ç‚¹å°±å†³å®šå¥½äº†ï¼Œä»èµ·ç‚¹å‡ºå‘ï¼Œâ€œæŒ‰é¡ºåºâ€å¡«å†™`dp`ç½‘æ ¼æ•°æ®ï¼Œè¿™ä¹Ÿæ˜¯åœ¨æ¨¡æ‹Ÿç¨‹åºå¤„ç†çš„è¿‡ç¨‹ã€‚
    - åœ¨æ­¤è¿‡ç¨‹ä¸­ï¼Œæ‚¨å°†è·å¾—å†™å‡ºâ€œé€’æ¨å…¬å¼â€çš„çµæ„Ÿã€‚å¦‚æœæ‚¨å·²ç»èƒ½æ¨å¯¼å‡ºå…¬å¼ï¼Œä¸éœ€è¦å¡«å®Œç½‘æ ¼ã€‚
4. æ ¹æ®`dp`ç½‘æ ¼æ•°æ®ï¼Œæ¨å¯¼å‡ºâ€œé€’æ¨å…¬å¼â€ã€‚
    - æœ‰ä¸‰ä¸ªç‰¹åˆ«çš„ä½ç½®éœ€è¦æ³¨æ„ï¼š `dp[i - 1][j - 1]`ã€`dp[i - 1][j]`å’Œ`dp[i][j - 1]`ï¼Œå½“å‰çš„ `dp[i][j]`å¾€å¾€å–å†³äºå®ƒä»¬ã€‚
    - æ“ä½œâ€œä¸¤ä¸ªå¯¹ç­‰æ•°ç»„â€æ—¶ï¼Œå› ä¸ºå¯¹ç§°æ€§ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦åŒæ—¶ä½¿ç”¨`dp[i - 1][j]`å’Œ`dp[i][j - 1]`ã€‚
5. å†™å‡ºç¨‹åºï¼Œå¹¶æ‰“å°`dp`æ•°ç»„ï¼Œä¸åˆé¢„æœŸå°±è°ƒæ•´ã€‚
    - é‡ç‚¹åˆ†æé‚£äº›ä¸åˆé¢„æœŸçš„æ•°å€¼ã€‚

è¯»å®Œäº†ä¸Šé¢çš„å†…å®¹ï¼Œæ˜¯ä¸æ˜¯æ„Ÿè§‰â€œåŠ¨æ€è§„åˆ’â€ä¹Ÿæ²¡æœ‰é‚£ä¹ˆéš¾äº†ï¼Ÿè¯•ç€è§£å‡ºè¿™é“é¢˜å§ã€‚ğŸ¤—

## å¤æ‚åº¦

- æ—¶é—´å¤æ‚åº¦: `O(n * sum/2)`.
- ç©ºé—´å¤æ‚åº¦: `O(n * sum/2)`.

## Python

```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        sum_ = sum(nums)

        if sum_ % 2 == 1:
            return False

        dp = [False] * ((sum_ // 2) + 1)
        dp[0] = True

        for num in nums:
            # Make a copy of the 'dp' that has not been modified to eliminate distractions.
            dc = dp.copy()

            for j in range(num, len(dp)): # any order is fine
                dp[j] = dc[j] or dc[j - num] # Use 'dc' instead of 'dp' because 'dp' will be modified.

        return dp[-1]
```

## C#

```csharp
public class Solution
{
    public bool CanPartition(int[] nums)
    {
        int sum = nums.Sum();

        if (sum % 2 == 1)
            return false;

        var dp = new bool[sum / 2 + 1];
        dp[0] = true;

        foreach (var num in nums)
        {
            var dc = (bool[])dp.Clone();

            for (var j = num; j < dp.Length; j++)
            {
                dp[j] = dc[j] || dc[j - num];
            }
        }

        return dp.Last();
    }
}
```

## C++

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        auto sum = reduce(nums.begin(), nums.end());

        if (sum % 2 == 1) {
            return false;
        }

        auto dp = vector<bool>(sum / 2 + 1);
        dp[0] = true;

        for (auto num : nums) {
            auto dc = dp;

            for (auto j = num; j < dp.size(); j++) {
                dp[j] = dc[j] || dc[j - num];
            }
        }

        return dp.back();
    }
};
```

## Java

```java
class Solution {
    public boolean canPartition(int[] nums) {
        var sum = IntStream.of(nums).sum();
        
        if (sum % 2 == 1) {
            return false;
        }

        var dp = new boolean[sum / 2 + 1];
        dp[0] = true;

        for (var num : nums) {
            var dc = dp.clone();

            for (var j = num; j < dp.length; j++) {
                dp[j] = dc[j] || dc[j - num];
            }
        }

        return dp[dp.length - 1];
    }
}
```

## JavaScript

```javascript
var canPartition = function (nums) {
  const sum = _.sum(nums)

  if (sum % 2 == 1) {
    return false
  }

  const dp = Array(sum / 2 + 1).fill(false)
  dp[0] = true

  for (const num of nums) {
    const dc = [...dp]

    for (let j = num; j < dp.length; j++) {
      dp[j] = dc[j] || dc[j - num]
    }
  }

  return dp.at(-1)
};
```

## Go

```go
func canPartition(nums []int) bool {
    sum := 0
    for _, num := range nums {
        sum += num
    }

    if sum % 2 == 1 {
        return false
    }

    dp := make([]bool, sum / 2 + 1)
    dp[0] = true

    for _, num := range nums {
        dc := slices.Clone(dp)

        for j := num; j < len(dp); j++ {
            dp[j] = dc[j] || dc[j - num]
        }
    }

    return dp[len(dp) - 1]
}
```

## Ruby

```ruby
def can_partition(nums)
  sum = nums.sum

  return false if sum % 2 == 1

  dp = Array.new(sum / 2 + 1, false)
  dp[0] = true

  nums.each do |num|
    dc = dp.clone

    (num...dp.size).each do |j|
      dp[j] = dc[j] || dc[j - num]
    end
  end

  dp[-1]
end
```

## Other languages

```java
// Welcome to create a PR to complete the code of this language, thanks!
```

äº²çˆ±çš„åŠ›æ‰£äººï¼Œä¸ºäº†æ‚¨æ›´å¥½çš„åˆ·é¢˜ä½“éªŒï¼Œè¯·è®¿é—® [leetcoder.net](https://leetcoder.net/zh)ã€‚
æœ¬ç«™æ•¢ç§°åŠ›æ‰£é¢˜è§£æœ€ä½³å®è·µï¼Œç»ˆå°†çœä½ å¤§é‡åˆ·é¢˜æ—¶é—´ï¼

åŸæ–‡é“¾æ¥ï¼š[416. åˆ†å‰²ç­‰å’Œå­é›† - åŠ›æ‰£é¢˜è§£æœ€ä½³å®è·µ](https://leetcoder.net/zh/leetcode/416-partition-equal-subset-sum).

GitHub ä»“åº“: [f*ck-leetcode](https://github.com/fuck-leetcode/fuck-leetcode).

